# عبارت های شرطی در bash

توی برنامه نویسی و کلا علوم کامپیوتر، ساختار ها و عبارت های شرطی یکی از ویژگی های مهم این حوزه ان. چرا؟ چون همیشه نیاز داریم که بلخره بعضی از شرط هارو بررسی کنیم و نسبت به اون ها اسکریپت یا برناممون رو جلو ببریم. مثال ساده اش میشه این که فرض کنید یه برنامه ساختید برای افراد بالای 18 سال، شما قبل از اجرا باید از کاربر بپرسید که 18 سالش هست یا نه، اگر بود اجرا بشه و اگر نبود باهاش بای بای کنید. 

داخل bash برای استفاده از عبارت های شرطی مرکب باید از `[[ ]]` استفاده کنید و برای دستورات داخلی (built-in) از `[ ]` استفاده کنید که جلوتر واضح تر میشه براتون! 

نیاز هم نیست همه اینارو حفظ کنید، میتونید یه برگه کوچیک بردارید و همشون رو اونجا بنویسید و هروقت نیاز به هرکدوم داشتید ازش استفاده کنید.

توجه کنید که این قسمت فقط برای آشناییه و قسمت بعدی یاد میگیریم چجوری توی کد ازشون استفاده کنیم! همچنین شرایط یا True هستن و یا False یعنی یا شرط درسته یا غلط.


## شرایط برای فایل ها - File expressions

* اگر فایلمون در سیستم موجود بود شرطمون درسته (یکمی منسوخ شده، پس بهتره استفاده نکنید)

```bash
[[ -a ${file} ]]
```

* اگر فایلمون در سیستم موجود بود و یه فایل ویژه (block special file) بود شرطمون درسته

```bash
[[ -b ${file} ]]
```

* اگر فایلمون در سیستم موجود بود و یه فایل با کارکتر ویژه (character special file) بود شرطمون درسته

```bash
[[ -c ${file} ]]
```

* اگر فایلمون موجود بود و یک دایرکتوری (پوشه) بود شرطمون درسته

```bash
[[ -d ${file} ]]
```

* اگر فایلمون در سیستم موجود بود شرطمون درسته (بهتره از این استفاده کنید)

```bash
[[ -e ${file} ]]
```

* اگر فایمون موجود بود و یه فایل معمولی بود شرطمون درسته

```bash
[[ -f ${file} ]]
```

* اگر فایلمون موجود بود و یه symbolic link بود شرطمون درسته

```bash
[[ -h ${file} ]]
```

* اگر فایل موجود بود و قابل خوندن بود شرمون درسته

```bash
[[ -r ${file} ]]
```

* اگر فایل موجود بود و سایز بیشتر از 0 بایت داشت، شرطمون درسته

```bash
[[ -s ${file} ]]
```

* اگر فایل موجود بود و قابل نوشتن بود، شرطمون درسته

```bash
[[ -w ${file} ]]
```

* اگر فایل موجود بود و قابل اجرا بود، شرطمون درسته

```bash
[[ -x ${file} ]]
```

* اگر فایلمون موجود بود و یه symbolic link بود شرطمون درسته

```bash
[[ -L ${file} ]]
```

## شرایط برای رشته ها - String expressions

* اگر متغیر پوسته varname مقداری داشته باشد شرمون درسته

```bash
[[ -v varname ]]
```

> توجه کنید که در مثال بالا varname اسم یه متغیره و به صورت `${varname}` استفاده نشده! چون عملگر `-v` انتظار داره فقط اسم رو بهش پاس بدید و اگه به صورت `${varname}` بهش پاس بدید، false یا غلط برمیگردونه!

* اگه طول رشته 0 باشه شرطمون درسته

```bash
[[ -z ${string} ]]
```

* اگه طول رشته غیر 0 باشه شرطمون درسته

```bash
[[ -n ${string} ]]
```

* اگر دو رشته باهم برابر باشند شرطمون درسته

```bash
[[ $string1 == $string2 ]]	# روش اول
[[ "$string1" = "$string2" ]]	# روش دوم (روش مطابق با POSIX و استاندارد)
[[ ${string1} == ${string2} ]]  	# روش سوم

```

> در روش دوم یدونه `=` داریم که باید باشه! چون `==` برای مقایسه الگوها هم استفاده میشه و اگه دقیقا میخواید فقط دوتا رشته رو باهم مقایسه کنید از روش دوم استفاده کنید.


* اگر دورشته برابر باهم نبودن شرطمون درسته

```bash
[[ ${string1} != ${string2} ]]
```

* اگر رشته سمت راست از رشته سمت چپ از نظر لغوی بزرگ تر باشه شرطمون درسته

```bash
[[ ${string1} < ${string2} ]]
```

* اگه رشته سمت راست از رشته سمت چپ از نظر لغوی کوچیک تر باشه شرطمون درسته

```bash
[[ ${string1} > ${string2} ]]
```

> شاید بگید مگه رشته ها عددن که بشه بزرگ تر و کوچیک تر رو حساب کرد؟ باید بگم دو رشته cat و car رو باهم مقایسه کنید. کارکتر اول جفتشون c عه پس تا فعلا برابرن، کارکتر بعدیشون a عه که اینجا هم برابرن اما کارکتر سومشون باهم فرق داره و یکی t و یکی r عه، توی حروف الفبای انگلیسی t بعد از r میاد پس بزرگتر حساب میشه!


## عملگرهای حسابی - Arithmetic operators

* اگر دو عدد با هم **برابر** باشند شرطمون درسته. `eq` مخفف کلمه equal عه.

```bash
[[ ${arg1} -eq ${arg2} ]]
```

* اگه دوتا عدد باهم **برابر نباشند** شرطمون درسته. `ne` مخفف not equal عه.

```bash
[[ ${arg1} -ne ${arg2} ]]
```

* اگر آرگومان اول از آرگومان دوم **کوچیک تر** باشه شرطمون درسته. `lt` مخفف less then عه.

```bash
[[ ${arg1} -lt ${arg2} ]]
```

* اگه آرگومان اول از آرگومان دوم **کوچیکتر مساوی** باشه شرطمون درسته. `le` مخفف less than or equal عه.

```bash
[[ ${arg1} -le ${arg2} ]]
```

* اگه آرگومان اول از آرگومان دوم **بزرگتر** باشه شرطمون درسته. `gt` مخفف greater than عه.

```bash
[[ ${arg1} -gt ${arg2} ]]
```

* اگه آرگومان اول از آرگومان دوم **بزرگتر مساوی** باشه شرطمون درسته. `ge` مخفف greater than or equal عه.

```bash
[[ ${arg1} -ge ${arg2} ]]
```

> به عنوان یه نکته، arg1 و arg2 میتونن اعداد صحیح مثبت یا منفی باشن.

توی بقیه زبان های برنامه نویسی میتونید چندین شرط رو باهم ترکیب کنید، توی bash هم میتونید این کار رو بکنید:

```bash
[[ test_case_1 ]] && [[ test_case_2 ]] # And
[[ test_case_1 ]] || [[ test_case_2 ]] # Or
```

> توی مثال بالا، زمانی شروط اولمون درسته که هر دو شرط درست باشه. (توی and زمانی شرط درسته که همه شرط ها درست باشن) و توی شروط دومون زمانی درسته که حداقل یکی از شرط ها درست باشه (توی or زمانی شرط درسته که حداقل یکیشون درست باشه)


## عملگرهای وضعیت خروج - Exit status operators

> داخل bash هر دستوری که مینویسم بعد از اجرا یه **کد خروجی** بر میگردونه. اگه برابر با 0 باشه یعنی خطا نداشتیم و هر عدد بزرگتر از 0 بده یعنی خطا داشتیم.

> برای اینکه بتونیم کد خروجی رو دریافت کنیم از `$?` استفاده میکنیم. هر دستور که احرا بشه، وضعیتش میره تو این.

* اگه آخرین دستورمون بدون خطا باشه شرطمون درسته

```bash
[[ $? -eq 0 ]]
```

* اگه دستورمون موفقیت آمیز نبود و خطا داشت شرطمون درسته

```bash
[[ $? -gt 0 ]]
```
